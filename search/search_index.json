{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Smart Mixin is a Python library for Clash configuration file manipulation.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Python &gt;= 3.10.0</p>"},{"location":"#installation","title":"Installation","text":"<p>To install Smart Mixin, run the following command in your terminal:</p> <pre><code>pip3 install smartmixin\n</code></pre> <p>Alternatively, you can clone the repository and install it manually:</p> <pre><code>git clone https://github.com/UFervor/SmartMixin.git\ncd SmartMixin\npip3 install .\n</code></pre>"},{"location":"#usage-examples","title":"Usage Examples","text":"<p>Here's a quick example to get you started. This script downloads a configuration from <code>https://example.com/abc</code>, removes all proxies whose names match the regex expression <code>Official Website|Expire</code>, and then dumps the modified YAML configuration to <code>config.yaml</code>.</p> <pre><code>from SmartMixin import Config, select_all, ClashforWindows\n\n# Initialize the configuration\nconf = Config(\"https://example.com/abc\", UA=ClashforWindows(\"0.20.39\"))\n\n# Select and delete the specified proxies\nselect_all(conf.Proxies, False, re_name=\"Official Website|Expire\").delete(globally=True)\n\n# Dump the modified configuration to a file\nwith open(\"config.yaml\", \"w\") as f:\n    f.write(conf.YAML)\n</code></pre>"},{"location":"ConfigHandler/","title":"Config Handler","text":""},{"location":"ConfigHandler/#config","title":"Config","text":""},{"location":"ConfigHandler/#SmartMixin.Config","title":"SmartMixin.Config","text":"<p>Config is a class that represents a Clash YAML configuration. It can be initialized with a URL, a YAML string, a file, or a dictionary (YAML representation).</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>class Config:\n    \"\"\"\n    Config is a class that represents a Clash YAML configuration.\n    It can be initialized with a URL, a YAML string, a file, or a dictionary (YAML representation).\n    \"\"\"\n\n    def __init__(self, Url: str = None, YAML: str = None, File: io.TextIOWrapper = None, DICT: dict = None, UA: str = Clash(\"1.11.0\")) -&gt; None:\n        \"\"\"\n        Initialize the Config with a URL, a YAML string, a file, or a dictionary (YAML representation).\n\n        Args:\n            Url (str, optional): URL to fetch the configuration from. Defaults to None.\n            YAML (str, optional): YAML string representing the configuration. Defaults to None.\n            File (io.TextIOWrapper, optional): File containing the configuration. Defaults to None.\n            DICT (dict, optional): Dictionary representing the configuration. Defaults to None.\n            UA (str, optional): User-agent string for the request. Defaults to Default(\"1.11.0\").\n\n        Raises:\n            ValueError: If none of Url, YAML, File, or DICT are provided.\n        \"\"\"\n\n        self._bypass = (\"DICT\", \"Proxies\", \"ProxyGroups\", \"Rules\", \"YAML\", \"_DICT\",\n                        \"_Proxies\", \"_ProxyGroups\", \"_Rules\", \"_meta\", \"__container__\")\n        self._meta = {}\n        self._Rules = WrapperList(self)\n        self._ProxyGroups = WrapperList(self)\n        self._Proxies = WrapperList(self)\n        self._DICT = {}\n        self._meta[\"headers\"] = {}\n        if DICT:\n            self.DICT = DICT\n        elif Url:\n            res = requests.get(Url, headers={\"user-agent\": UA})\n            try:\n                self._meta[\"headers\"][\"subscription-userinfo\"] = res.headers[\"subscription-userinfo\"]\n            except:\n                pass\n            try:\n                self._meta[\"headers\"][\"profile-update-interval\"] = res.headers[\"profile-update-interval\"]\n            except:\n                pass\n            try:\n                self._meta[\"headers\"][\"profile-web-page-url\"] = res.headers[\"profile-web-page-url\"]\n            except:\n                pass\n            self.YAML = res.text\n        elif YAML:\n            self.YAML = YAML\n        elif File:\n            self.YAML = File.read()\n        else:\n            raise ValueError\n\n    def __setattr__(self, __name: str, __value) -&gt; None:\n        \"\"\"\n        Rewrite the __setattr__ method to intercept attribute assignments and store them in the _meta dictionary.\n\n        Args:\n            __name (str): Name of the attribute.\n            __value: Value of the attribute.\n        \"\"\"\n\n        if __name == \"_bypass\" or __name in self._bypass:\n            object.__setattr__(self, __name, __value)\n        else:\n            self._meta[__name] = __value\n\n    def __getattr__(self, __name: str):\n        \"\"\"\n        Get an attribute of the configuration.\n\n        Args:\n            __name (str): Name of the attribute.\n\n        Returns:\n            The value of the attribute.\n        \"\"\"\n\n        if __name == \"_bypass\" or __name in self._bypass:\n            return object.__getattribute__(self, __name)\n        else:\n            return self._meta[__name]\n\n    @property\n    def Proxies(self) -&gt; list[Proxy]:\n        \"\"\"\n        Get all proxies.\n\n        Returns:\n            list[Proxy]: List of all proxies.\n        \"\"\"\n\n        return self._Proxies\n\n    @Proxies.setter\n    def Proxies(self, Proxies: list[Proxy]) -&gt; None:\n        \"\"\"\n        Rewrite the Proxies setter to store the proxies in a WrapperList.\n\n        Returns:\n            list[ProxyGroup]: List of Proxy objects.\n        \"\"\"\n\n        self._Proxies = WrapperList(self, Proxies)\n\n    @property\n    def ProxyGroups(self) -&gt; list[ProxyGroup]:\n        \"\"\"\n        Get all proxygroups.\n\n        Returns:\n            list[ProxyGroup]: List of all proxygroups.\n        \"\"\"\n\n        return self._ProxyGroups\n\n    @ProxyGroups.setter\n    def ProxyGroups(self, ProxyGroups: list[ProxyGroup]) -&gt; None:\n        \"\"\"\n        Rewrite the ProxyGroups setter to store the proxygroups in a WrapperList.\n\n        Args:\n            ProxyGroups (list[ProxyGroup]): List of ProxyGroup objects.\n        \"\"\"\n\n        self._ProxyGroups = WrapperList(self, ProxyGroups)\n\n    @property\n    def Rules(self) -&gt; list[Rule]:\n        \"\"\"\n        Get all rules.\n\n        Returns:\n            list[Rule]: List of Rule objects.\n        \"\"\"\n\n        return self._Rules\n\n    @Rules.setter\n    def Rules(self, Rules: list[Rule]) -&gt; None:\n        \"\"\"\n        Rewrite the Rules setter to store the rules in a WrapperList.\n\n        Args:\n            Rules (list[Rule]): List of Rule objects.\n        \"\"\"\n\n        self._Rules = WrapperList(self, Rules)\n\n    def getProxies(self, groups: bool = False, embedded: bool = False) -&gt; list[Proxy]:\n        \"\"\"\n        Get all proxies, optionally including proxygroups and embedded proxies.\n\n        Args:\n            groups (bool, optional): Whether to include proxygroups. Defaults to False.\n            embedded (bool, optional): Whether to include embedded proxies. Defaults to False.\n\n        Returns:\n            list[Proxy]: List of Proxy objects.\n        \"\"\"\n\n        result = self.Proxies\n        if groups:\n            result += [\n                Proxy(DICT={\"name\": i.name})\n                for i in self.ProxyGroups\n            ]\n        if embedded:\n            result += [\n                DIRECT,\n                REJECT\n            ]\n        return result\n\n    def mixin(self, YAML: str = None, DICT: dict = None) -&gt; None:\n        \"\"\"\n        Mix additional configuration from a YAML string or a dictionary.\n\n        Args:\n            YAML (str, optional): YAML string representing additional configuration. Defaults to None.\n            DICT (dict, optional): Dictionary representing additional configuration. Defaults to None.\n\n        Raises:\n            ValueError: If neither YAML nor DICT is provided.\n        \"\"\"\n\n        if DICT:\n            YAML = yaml.dump(self.DICT, Dumper=NoAliasDumper)\n        elif YAML:\n            pass\n        else:\n            raise ValueError()\n        self.YAML = self.YAML + \"\\n\" + YAML\n\n    @property\n    def DICT(self) -&gt; dict:\n        \"\"\"\n        Get the dictionary representation of the configuration.\n\n        Returns:\n            dict: Dictionary representation of the configuration.\n        \"\"\"\n\n        self._DICT[\"proxies\"] = [i.DICT for i in self.Proxies]\n        self._DICT[\"proxy-groups\"] = [i.DICT for i in self.ProxyGroups]\n        self._DICT[\"rules\"] = [i.YAML for i in self.Rules]\n        return self._DICT\n\n    @DICT.setter\n    def DICT(self, DICT: dict) -&gt; None:\n        \"\"\"\n        Set the configuration from a dictionary representation.\n\n        Args:\n            DICT (dict): Dictionary representing the configuration.\n        \"\"\"\n\n        self._DICT = DICT\n        for i in self._DICT[\"proxy-groups\"]:\n            self.ProxyGroups.append(ProxyGroup(DICT=i))\n        for i in self._DICT[\"proxies\"]:\n            self.Proxies.append(Proxy(DICT=i))\n        for i in self._DICT[\"rules\"]:\n            self.Rules.append(Rule(YAML=i))\n\n    @property\n    def YAML(self) -&gt; str:\n        \"\"\"\n        Get the YAML representation of the configuration.\n\n        Returns:\n            str: YAML representation of the configuration.\n        \"\"\"\n\n        return yaml.dump(self.DICT, Dumper=NoAliasDumper)\n\n    @YAML.setter\n    def YAML(self, YAML: str) -&gt; None:\n        \"\"\"\n        Set the configuration from a YAML string.\n\n        Args:\n            YAML (str): YAML configuration string.\n        \"\"\"\n\n        self.DICT = yaml.load(YAML.encode(\"utf-8\"), Loader=yaml.Loader)\n\n    def strip(self) -&gt; None:\n        \"\"\"\n        Remove any empty proxygroup.\n        \"\"\"\n\n        for i in self.ProxyGroups:\n            if len(i.proxies) == 0:\n                i.delete()\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.Config.DICT","title":"DICT  <code>property</code> <code>writable</code>","text":"<pre><code>DICT: dict\n</code></pre> <p>Get the dictionary representation of the configuration.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary representation of the configuration.</p>"},{"location":"ConfigHandler/#SmartMixin.Config.Proxies","title":"Proxies  <code>property</code> <code>writable</code>","text":"<pre><code>Proxies: list[Proxy]\n</code></pre> <p>Get all proxies.</p> <p>Returns:</p> Type Description <code>list[Proxy]</code> <p>list[Proxy]: List of all proxies.</p>"},{"location":"ConfigHandler/#SmartMixin.Config.ProxyGroups","title":"ProxyGroups  <code>property</code> <code>writable</code>","text":"<pre><code>ProxyGroups: list[ProxyGroup]\n</code></pre> <p>Get all proxygroups.</p> <p>Returns:</p> Type Description <code>list[ProxyGroup]</code> <p>list[ProxyGroup]: List of all proxygroups.</p>"},{"location":"ConfigHandler/#SmartMixin.Config.Rules","title":"Rules  <code>property</code> <code>writable</code>","text":"<pre><code>Rules: list[Rule]\n</code></pre> <p>Get all rules.</p> <p>Returns:</p> Type Description <code>list[Rule]</code> <p>list[Rule]: List of Rule objects.</p>"},{"location":"ConfigHandler/#SmartMixin.Config.YAML","title":"YAML  <code>property</code> <code>writable</code>","text":"<pre><code>YAML: str\n</code></pre> <p>Get the YAML representation of the configuration.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>YAML representation of the configuration.</p>"},{"location":"ConfigHandler/#SmartMixin.Config.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(__name: str)\n</code></pre> <p>Get an attribute of the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>__name</code> <code>str</code> <p>Name of the attribute.</p> required <p>Returns:</p> Type Description <p>The value of the attribute.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>def __getattr__(self, __name: str):\n    \"\"\"\n    Get an attribute of the configuration.\n\n    Args:\n        __name (str): Name of the attribute.\n\n    Returns:\n        The value of the attribute.\n    \"\"\"\n\n    if __name == \"_bypass\" or __name in self._bypass:\n        return object.__getattribute__(self, __name)\n    else:\n        return self._meta[__name]\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.Config.__init__","title":"__init__","text":"<pre><code>__init__(Url: str = None, YAML: str = None, File: TextIOWrapper = None, DICT: dict = None, UA: str = Clash('1.11.0')) -&gt; None\n</code></pre> <p>Initialize the Config with a URL, a YAML string, a file, or a dictionary (YAML representation).</p> <p>Parameters:</p> Name Type Description Default <code>Url</code> <code>str</code> <p>URL to fetch the configuration from. Defaults to None.</p> <code>None</code> <code>YAML</code> <code>str</code> <p>YAML string representing the configuration. Defaults to None.</p> <code>None</code> <code>File</code> <code>TextIOWrapper</code> <p>File containing the configuration. Defaults to None.</p> <code>None</code> <code>DICT</code> <code>dict</code> <p>Dictionary representing the configuration. Defaults to None.</p> <code>None</code> <code>UA</code> <code>str</code> <p>User-agent string for the request. Defaults to Default(\"1.11.0\").</p> <code>Clash('1.11.0')</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If none of Url, YAML, File, or DICT are provided.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>def __init__(self, Url: str = None, YAML: str = None, File: io.TextIOWrapper = None, DICT: dict = None, UA: str = Clash(\"1.11.0\")) -&gt; None:\n    \"\"\"\n    Initialize the Config with a URL, a YAML string, a file, or a dictionary (YAML representation).\n\n    Args:\n        Url (str, optional): URL to fetch the configuration from. Defaults to None.\n        YAML (str, optional): YAML string representing the configuration. Defaults to None.\n        File (io.TextIOWrapper, optional): File containing the configuration. Defaults to None.\n        DICT (dict, optional): Dictionary representing the configuration. Defaults to None.\n        UA (str, optional): User-agent string for the request. Defaults to Default(\"1.11.0\").\n\n    Raises:\n        ValueError: If none of Url, YAML, File, or DICT are provided.\n    \"\"\"\n\n    self._bypass = (\"DICT\", \"Proxies\", \"ProxyGroups\", \"Rules\", \"YAML\", \"_DICT\",\n                    \"_Proxies\", \"_ProxyGroups\", \"_Rules\", \"_meta\", \"__container__\")\n    self._meta = {}\n    self._Rules = WrapperList(self)\n    self._ProxyGroups = WrapperList(self)\n    self._Proxies = WrapperList(self)\n    self._DICT = {}\n    self._meta[\"headers\"] = {}\n    if DICT:\n        self.DICT = DICT\n    elif Url:\n        res = requests.get(Url, headers={\"user-agent\": UA})\n        try:\n            self._meta[\"headers\"][\"subscription-userinfo\"] = res.headers[\"subscription-userinfo\"]\n        except:\n            pass\n        try:\n            self._meta[\"headers\"][\"profile-update-interval\"] = res.headers[\"profile-update-interval\"]\n        except:\n            pass\n        try:\n            self._meta[\"headers\"][\"profile-web-page-url\"] = res.headers[\"profile-web-page-url\"]\n        except:\n            pass\n        self.YAML = res.text\n    elif YAML:\n        self.YAML = YAML\n    elif File:\n        self.YAML = File.read()\n    else:\n        raise ValueError\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.Config.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(__name: str, __value) -&gt; None\n</code></pre> <p>Rewrite the setattr method to intercept attribute assignments and store them in the _meta dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>__name</code> <code>str</code> <p>Name of the attribute.</p> required <code>__value</code> <p>Value of the attribute.</p> required Source code in <code>SmartMixin/handler.py</code> <pre><code>def __setattr__(self, __name: str, __value) -&gt; None:\n    \"\"\"\n    Rewrite the __setattr__ method to intercept attribute assignments and store them in the _meta dictionary.\n\n    Args:\n        __name (str): Name of the attribute.\n        __value: Value of the attribute.\n    \"\"\"\n\n    if __name == \"_bypass\" or __name in self._bypass:\n        object.__setattr__(self, __name, __value)\n    else:\n        self._meta[__name] = __value\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.Config.getProxies","title":"getProxies","text":"<pre><code>getProxies(groups: bool = False, embedded: bool = False) -&gt; list[Proxy]\n</code></pre> <p>Get all proxies, optionally including proxygroups and embedded proxies.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>bool</code> <p>Whether to include proxygroups. Defaults to False.</p> <code>False</code> <code>embedded</code> <code>bool</code> <p>Whether to include embedded proxies. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Proxy]</code> <p>list[Proxy]: List of Proxy objects.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>def getProxies(self, groups: bool = False, embedded: bool = False) -&gt; list[Proxy]:\n    \"\"\"\n    Get all proxies, optionally including proxygroups and embedded proxies.\n\n    Args:\n        groups (bool, optional): Whether to include proxygroups. Defaults to False.\n        embedded (bool, optional): Whether to include embedded proxies. Defaults to False.\n\n    Returns:\n        list[Proxy]: List of Proxy objects.\n    \"\"\"\n\n    result = self.Proxies\n    if groups:\n        result += [\n            Proxy(DICT={\"name\": i.name})\n            for i in self.ProxyGroups\n        ]\n    if embedded:\n        result += [\n            DIRECT,\n            REJECT\n        ]\n    return result\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.Config.mixin","title":"mixin","text":"<pre><code>mixin(YAML: str = None, DICT: dict = None) -&gt; None\n</code></pre> <p>Mix additional configuration from a YAML string or a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>YAML</code> <code>str</code> <p>YAML string representing additional configuration. Defaults to None.</p> <code>None</code> <code>DICT</code> <code>dict</code> <p>Dictionary representing additional configuration. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither YAML nor DICT is provided.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>def mixin(self, YAML: str = None, DICT: dict = None) -&gt; None:\n    \"\"\"\n    Mix additional configuration from a YAML string or a dictionary.\n\n    Args:\n        YAML (str, optional): YAML string representing additional configuration. Defaults to None.\n        DICT (dict, optional): Dictionary representing additional configuration. Defaults to None.\n\n    Raises:\n        ValueError: If neither YAML nor DICT is provided.\n    \"\"\"\n\n    if DICT:\n        YAML = yaml.dump(self.DICT, Dumper=NoAliasDumper)\n    elif YAML:\n        pass\n    else:\n        raise ValueError()\n    self.YAML = self.YAML + \"\\n\" + YAML\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.Config.strip","title":"strip","text":"<pre><code>strip() -&gt; None\n</code></pre> <p>Remove any empty proxygroup.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>def strip(self) -&gt; None:\n    \"\"\"\n    Remove any empty proxygroup.\n    \"\"\"\n\n    for i in self.ProxyGroups:\n        if len(i.proxies) == 0:\n            i.delete()\n</code></pre>"},{"location":"ConfigHandler/#user-agent-helper","title":"User-Agent Helper","text":""},{"location":"ConfigHandler/#SmartMixin.Clash","title":"SmartMixin.Clash  <code>module-attribute</code>","text":"<pre><code>Clash = lambda : f'Clash/{ClashCoreVersion}'\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.Stash","title":"SmartMixin.Stash  <code>module-attribute</code>","text":"<pre><code>Stash = lambda , : f'StashCore/{StashVersion} Stash/{StashVersion} Clash/{ClashCoreVersion}'\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.ClashforWindows","title":"SmartMixin.ClashforWindows  <code>module-attribute</code>","text":"<pre><code>ClashforWindows = lambda : f'ClashforWindows/{ClashforWindowsVersion}'\n</code></pre>"},{"location":"ConfigHandler/#proxy","title":"Proxy","text":""},{"location":"ConfigHandler/#SmartMixin.Proxy","title":"SmartMixin.Proxy","text":"<p>Proxy is a class that represents a proxy defined in the Clash YAML configuration.  It has properties like name and DICT. The class can be initialized with either  a YAML string or a dictionary (YAML representation).</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>class Proxy:\n    \"\"\"\n    Proxy is a class that represents a proxy defined in the Clash YAML configuration. \n    It has properties like name and DICT. The class can be initialized with either \n    a YAML string or a dictionary (YAML representation).\n    \"\"\"\n\n    def __init__(self, DICT: dict = None, YAML: str = None) -&gt; None:\n        \"\"\"\n        Initialize the Proxy object with either a dictionary or a YAML string.\n\n        Args:\n            DICT (dict, optional): A dictionary representing a proxy. Defaults to None.\n            YAML (str, optional): A string representing a proxy in YAML format. Defaults to None.\n\n        Raises:\n            ValueError: If both DICT and YAML are None.\n        \"\"\"\n\n        if DICT:\n            self.DICT = DICT\n        elif YAML:\n            soup = yaml.load(YAML.encode(\"utf-8\"), Loader=yaml.Loader)\n            if isinstance(soup, list):\n                soup = soup[0]\n            self.DICT = soup\n        else:\n            raise ValueError\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the proxy.\n\n        Returns:\n            str: The name of the proxy.\n        \"\"\"\n\n        return self.DICT[\"name\"]\n\n    @name.setter\n    def name(self, name: str) -&gt; None:\n        \"\"\"\n        Set the name of the proxy.\n\n        Args:\n            name (str): The new name of the proxy.\n        \"\"\"\n\n        if isinstance(self.__container__, ProxyGroup):\n            __container__ = self.__container__.__container__\n        elif isinstance(self.__container__, Config):\n            __container__ = self.__container__\n        foregone = self.DICT[\"name\"]\n        if not foregone == name:\n            self.DICT[\"name\"] = name\n            for i in range(len(__container__.ProxyGroups) - 1, -1, -1):\n                for j in __container__.ProxyGroups[i].proxies:\n                    if j.name == foregone:\n                        j.name = name\n\n    def delete(self, globally: bool = False) -&gt; None:\n        \"\"\"\n        Delete the proxy from its proxygroup. If globally is True, the proxy is \n        removed from the configuration file.\n\n        Args:\n            globally (bool, optional): If True, the proxy is removed from the configuration file. \n            Defaults to False.\n        \"\"\"\n\n        try:\n            if isinstance(self.__container__, ProxyGroup):\n                self.__container__.proxies.remove(self)\n            elif isinstance(self.__container__, Config):\n                globally = True\n        except:\n            pass\n        if globally:\n            try:\n                if isinstance(self.__container__, ProxyGroup):\n                    __container__ = self.__container__.__container__\n                elif isinstance(self.__container__, Config):\n                    __container__ = self.__container__\n                for i in range(len(__container__.ProxyGroups) - 1, -1, -1):\n                    for j in range(len(__container__.ProxyGroups[i].proxies) - 1, -1, -1):\n                        if __container__.ProxyGroups[i].proxies[j].name == self.name:\n                            __container__.ProxyGroups[i].proxies.pop(j)\n                for i in range(len(__container__.Proxies) - 1, -1, -1):\n                    if __container__.Proxies[i].name == self.name:\n                        __container__.Proxies.pop(i)\n            except:\n                pass\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Get a string representation of the proxy.\n\n        Returns:\n            str: A string representation of the proxy.\n        \"\"\"\n\n        return f\"&lt;PreProcessor.Proxy object {self.name} at {hex(id(self))}&gt;\"\n\n    def BATCH(YAML) -&gt; list:\n        \"\"\"\n        Create a list of Proxy objects from a YAML string.\n\n        Args:\n            YAML (str): A string representing multiple proxies in YAML format.\n\n        Raises:\n            ValueError: If the YAML string does not represent a list of proxies.\n\n        Returns:\n            list: A list of Proxy objects.\n        \"\"\"\n\n        soup = yaml.load(YAML.encode(\"utf-8\"), Loader=yaml.Loader)\n        if isinstance(soup, list):\n            return [Proxy(i) for i in soup]\n        else:\n            raise ValueError(\"YAML List Expected\")\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.Proxy.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the proxy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the proxy.</p>"},{"location":"ConfigHandler/#SmartMixin.Proxy.BATCH","title":"BATCH","text":"<pre><code>BATCH(YAML) -&gt; list\n</code></pre> <p>Create a list of Proxy objects from a YAML string.</p> <p>Parameters:</p> Name Type Description Default <code>YAML</code> <code>str</code> <p>A string representing multiple proxies in YAML format.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the YAML string does not represent a list of proxies.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of Proxy objects.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>def BATCH(YAML) -&gt; list:\n    \"\"\"\n    Create a list of Proxy objects from a YAML string.\n\n    Args:\n        YAML (str): A string representing multiple proxies in YAML format.\n\n    Raises:\n        ValueError: If the YAML string does not represent a list of proxies.\n\n    Returns:\n        list: A list of Proxy objects.\n    \"\"\"\n\n    soup = yaml.load(YAML.encode(\"utf-8\"), Loader=yaml.Loader)\n    if isinstance(soup, list):\n        return [Proxy(i) for i in soup]\n    else:\n        raise ValueError(\"YAML List Expected\")\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.Proxy.__init__","title":"__init__","text":"<pre><code>__init__(DICT: dict = None, YAML: str = None) -&gt; None\n</code></pre> <p>Initialize the Proxy object with either a dictionary or a YAML string.</p> <p>Parameters:</p> Name Type Description Default <code>DICT</code> <code>dict</code> <p>A dictionary representing a proxy. Defaults to None.</p> <code>None</code> <code>YAML</code> <code>str</code> <p>A string representing a proxy in YAML format. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both DICT and YAML are None.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>def __init__(self, DICT: dict = None, YAML: str = None) -&gt; None:\n    \"\"\"\n    Initialize the Proxy object with either a dictionary or a YAML string.\n\n    Args:\n        DICT (dict, optional): A dictionary representing a proxy. Defaults to None.\n        YAML (str, optional): A string representing a proxy in YAML format. Defaults to None.\n\n    Raises:\n        ValueError: If both DICT and YAML are None.\n    \"\"\"\n\n    if DICT:\n        self.DICT = DICT\n    elif YAML:\n        soup = yaml.load(YAML.encode(\"utf-8\"), Loader=yaml.Loader)\n        if isinstance(soup, list):\n            soup = soup[0]\n        self.DICT = soup\n    else:\n        raise ValueError\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.Proxy.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Get a string representation of the proxy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the proxy.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Get a string representation of the proxy.\n\n    Returns:\n        str: A string representation of the proxy.\n    \"\"\"\n\n    return f\"&lt;PreProcessor.Proxy object {self.name} at {hex(id(self))}&gt;\"\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.Proxy.delete","title":"delete","text":"<pre><code>delete(globally: bool = False) -&gt; None\n</code></pre> <p>Delete the proxy from its proxygroup. If globally is True, the proxy is  removed from the configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>globally</code> <code>bool</code> <p>If True, the proxy is removed from the configuration file. </p> <code>False</code> Source code in <code>SmartMixin/handler.py</code> <pre><code>def delete(self, globally: bool = False) -&gt; None:\n    \"\"\"\n    Delete the proxy from its proxygroup. If globally is True, the proxy is \n    removed from the configuration file.\n\n    Args:\n        globally (bool, optional): If True, the proxy is removed from the configuration file. \n        Defaults to False.\n    \"\"\"\n\n    try:\n        if isinstance(self.__container__, ProxyGroup):\n            self.__container__.proxies.remove(self)\n        elif isinstance(self.__container__, Config):\n            globally = True\n    except:\n        pass\n    if globally:\n        try:\n            if isinstance(self.__container__, ProxyGroup):\n                __container__ = self.__container__.__container__\n            elif isinstance(self.__container__, Config):\n                __container__ = self.__container__\n            for i in range(len(__container__.ProxyGroups) - 1, -1, -1):\n                for j in range(len(__container__.ProxyGroups[i].proxies) - 1, -1, -1):\n                    if __container__.ProxyGroups[i].proxies[j].name == self.name:\n                        __container__.ProxyGroups[i].proxies.pop(j)\n            for i in range(len(__container__.Proxies) - 1, -1, -1):\n                if __container__.Proxies[i].name == self.name:\n                    __container__.Proxies.pop(i)\n        except:\n            pass\n</code></pre>"},{"location":"ConfigHandler/#embedded-proxy","title":"Embedded Proxy","text":""},{"location":"ConfigHandler/#SmartMixin.DIRECT","title":"SmartMixin.DIRECT  <code>module-attribute</code>","text":"<pre><code>DIRECT = Proxy(DICT={'name': 'DIRECT'})\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.REJECT","title":"SmartMixin.REJECT  <code>module-attribute</code>","text":"<pre><code>REJECT = Proxy(DICT={'name': 'REJECT'})\n</code></pre>"},{"location":"ConfigHandler/#proxygroup","title":"ProxyGroup","text":""},{"location":"ConfigHandler/#SmartMixin.ProxyGroup","title":"SmartMixin.ProxyGroup","text":"<p>ProxyGroup is a class that represents a proxygroup defined in the Clash YAML configuration.  It has properties like name, proxies, and DICT. The class can be initialized with either  a dictionary (YAML representation) or a YAML string.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>class ProxyGroup:\n    \"\"\"\n    ProxyGroup is a class that represents a proxygroup defined in the Clash YAML configuration. \n    It has properties like name, proxies, and DICT. The class can be initialized with either \n    a dictionary (YAML representation) or a YAML string.\n    \"\"\"\n\n    def __init__(self, DICT: dict = None, YAML: str = None) -&gt; None:\n        \"\"\"\n        Initialize the ProxyGroup with either a dictionary or a YAML string.\n\n        Args:\n            DICT (dict, optional): A dictionary representing a proxygroup. Defaults to None.\n            YAML (str, optional): A string representing a proxygroup in YAML format. Defaults to None.\n\n        Raises:\n            ValueError: If both DICT and YAML are None.\n        \"\"\"\n\n        if DICT:\n            self.DICT = DICT\n        elif YAML:\n            soup = yaml.load(YAML.encode(\"utf-8\"), Loader=yaml.Loader)\n            if isinstance(soup, list):\n                soup = soup[0]\n            self.DICT = soup\n        else:\n            raise ValueError\n\n    @property\n    def proxies(self) -&gt; list[Proxy]:\n        \"\"\"\n        Get the list of proxies in the proxygroup.\n\n        Returns:\n            list[Proxy]: The list of proxies in the proxygroup.\n        \"\"\"\n\n        return self._proxies\n\n    @proxies.setter\n    def proxies(self, proxies: list[Proxy]) -&gt; None:\n        \"\"\"\n        Set the list of proxies in the proxygroup.\n\n        Args:\n            proxies (list[Proxy]): The new list of proxies for the proxygroup.\n        \"\"\"\n\n        self._proxies = WrapperList(self, proxies)\n\n    @property\n    def DICT(self) -&gt; dict:\n        \"\"\"\n        Get the dictionary representation of the proxygroup.\n\n        Returns:\n            dict: The dictionary representation of the proxygroup.\n        \"\"\"\n\n        self._DICT[\"proxies\"] = [i.name for i in self._proxies]\n        return self._DICT\n\n    @DICT.setter\n    def DICT(self, DICT: dict) -&gt; None:\n        \"\"\"\n        Set the properties of the ProxyGroup from a dictionary.\n\n        Args:\n            DICT (dict): A dictionary representing a proxygroup.\n        \"\"\"\n\n        self._DICT = DICT\n        self.proxies = [Proxy(DICT={\"name\": i.name}) if isinstance(\n            i, Proxy) else Proxy(DICT={\"name\": i}) for i in self._DICT[\"proxies\"]]\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the proxygroup.\n\n        Returns:\n            str: The name of the proxygroup.\n        \"\"\"\n\n        return self._DICT[\"name\"]\n\n    @name.setter\n    def name(self, name: str) -&gt; None:\n        \"\"\"\n        Set the name of the proxygroup.\n\n        Args:\n            name (str): The new name of the proxygroup.\n        \"\"\"\n\n        foregone = self._DICT[\"name\"]\n        if not foregone == name:\n            self._DICT[\"name\"] = name\n            try:\n                for i in range(len(self.__container__.ProxyGroups) - 1, -1, -1):\n                    for j in self.__container__.ProxyGroups[i].proxies:\n                        if j.name == foregone:\n                            j.name = name\n                for i in self.__container__.Rules:\n                    if i.policy == foregone:\n                        i.policy = name\n            except:\n                pass\n\n    def delete(self, policy: str = None) -&gt; None:\n        \"\"\"\n        Delete the proxygroup. If a policy is provided, all rules with \n        the proxygroup's name as their policy will be updated to use the provided policy.\n\n        Args:\n            policy (str, optional): The new policy for rules that use the proxygroup's name as their policy. \n            Defaults to None.\n        \"\"\"\n\n        if policy == None:\n            try:\n                for i in range(len(self.__container__.Rules) - 1, -1, -1):\n                    if self.__container__.Rules[i].policy == self.name:\n                        self.__container__.Rules[i].delete()\n            except:\n                pass\n        else:\n            try:\n                for i in range(len(self.__container__.Rules)):\n                    if self.__container__.Rules[i].policy == self.name:\n                        self.__container__.Rules[i].policy = policy\n            except:\n                pass\n        try:\n            self.__container__.ProxyGroups.remove(self)\n        except:\n            pass\n        try:\n            for i in range(len(self.__container__.ProxyGroups) - 1, -1, -1):\n                select(\n                    self.__container__.ProxyGroups[i].proxies, False, name=self.name).delete()\n        except:\n            pass\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Get a string representation of the proxygroup.\n\n        Returns:\n            str: A string representation of the proxygroup.\n        \"\"\"\n\n        return f\"&lt;PreProcessor.ProxyGroup object {self.name} at {hex(id(self))}&gt;\"\n\n    def BATCH(YAML: str) -&gt; list:\n        \"\"\"\n        Create a list of ProxyGroup objects from a YAML string.\n\n        Args:\n            YAML (str): A string representing multiple proxygroups in YAML format.\n\n        Raises:\n            ValueError: If the YAML string does not represent a list of proxygroups.\n\n        Returns:\n            list: A list of ProxyGroup objects.\n        \"\"\"\n\n        soup = yaml.load(YAML.encode(\"utf-8\"), Loader=yaml.Loader)\n        if isinstance(soup, list):\n            return [ProxyGroup(i) for i in soup]\n        else:\n            raise ValueError(\"YAML List Expected\")\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.ProxyGroup.DICT","title":"DICT  <code>property</code> <code>writable</code>","text":"<pre><code>DICT: dict\n</code></pre> <p>Get the dictionary representation of the proxygroup.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the proxygroup.</p>"},{"location":"ConfigHandler/#SmartMixin.ProxyGroup.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the proxygroup.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the proxygroup.</p>"},{"location":"ConfigHandler/#SmartMixin.ProxyGroup.proxies","title":"proxies  <code>property</code> <code>writable</code>","text":"<pre><code>proxies: list[Proxy]\n</code></pre> <p>Get the list of proxies in the proxygroup.</p> <p>Returns:</p> Type Description <code>list[Proxy]</code> <p>list[Proxy]: The list of proxies in the proxygroup.</p>"},{"location":"ConfigHandler/#SmartMixin.ProxyGroup.BATCH","title":"BATCH","text":"<pre><code>BATCH(YAML: str) -&gt; list\n</code></pre> <p>Create a list of ProxyGroup objects from a YAML string.</p> <p>Parameters:</p> Name Type Description Default <code>YAML</code> <code>str</code> <p>A string representing multiple proxygroups in YAML format.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the YAML string does not represent a list of proxygroups.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of ProxyGroup objects.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>def BATCH(YAML: str) -&gt; list:\n    \"\"\"\n    Create a list of ProxyGroup objects from a YAML string.\n\n    Args:\n        YAML (str): A string representing multiple proxygroups in YAML format.\n\n    Raises:\n        ValueError: If the YAML string does not represent a list of proxygroups.\n\n    Returns:\n        list: A list of ProxyGroup objects.\n    \"\"\"\n\n    soup = yaml.load(YAML.encode(\"utf-8\"), Loader=yaml.Loader)\n    if isinstance(soup, list):\n        return [ProxyGroup(i) for i in soup]\n    else:\n        raise ValueError(\"YAML List Expected\")\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.ProxyGroup.__init__","title":"__init__","text":"<pre><code>__init__(DICT: dict = None, YAML: str = None) -&gt; None\n</code></pre> <p>Initialize the ProxyGroup with either a dictionary or a YAML string.</p> <p>Parameters:</p> Name Type Description Default <code>DICT</code> <code>dict</code> <p>A dictionary representing a proxygroup. Defaults to None.</p> <code>None</code> <code>YAML</code> <code>str</code> <p>A string representing a proxygroup in YAML format. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both DICT and YAML are None.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>def __init__(self, DICT: dict = None, YAML: str = None) -&gt; None:\n    \"\"\"\n    Initialize the ProxyGroup with either a dictionary or a YAML string.\n\n    Args:\n        DICT (dict, optional): A dictionary representing a proxygroup. Defaults to None.\n        YAML (str, optional): A string representing a proxygroup in YAML format. Defaults to None.\n\n    Raises:\n        ValueError: If both DICT and YAML are None.\n    \"\"\"\n\n    if DICT:\n        self.DICT = DICT\n    elif YAML:\n        soup = yaml.load(YAML.encode(\"utf-8\"), Loader=yaml.Loader)\n        if isinstance(soup, list):\n            soup = soup[0]\n        self.DICT = soup\n    else:\n        raise ValueError\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.ProxyGroup.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Get a string representation of the proxygroup.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the proxygroup.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Get a string representation of the proxygroup.\n\n    Returns:\n        str: A string representation of the proxygroup.\n    \"\"\"\n\n    return f\"&lt;PreProcessor.ProxyGroup object {self.name} at {hex(id(self))}&gt;\"\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.ProxyGroup.delete","title":"delete","text":"<pre><code>delete(policy: str = None) -&gt; None\n</code></pre> <p>Delete the proxygroup. If a policy is provided, all rules with  the proxygroup's name as their policy will be updated to use the provided policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>str</code> <p>The new policy for rules that use the proxygroup's name as their policy. </p> <code>None</code> Source code in <code>SmartMixin/handler.py</code> <pre><code>def delete(self, policy: str = None) -&gt; None:\n    \"\"\"\n    Delete the proxygroup. If a policy is provided, all rules with \n    the proxygroup's name as their policy will be updated to use the provided policy.\n\n    Args:\n        policy (str, optional): The new policy for rules that use the proxygroup's name as their policy. \n        Defaults to None.\n    \"\"\"\n\n    if policy == None:\n        try:\n            for i in range(len(self.__container__.Rules) - 1, -1, -1):\n                if self.__container__.Rules[i].policy == self.name:\n                    self.__container__.Rules[i].delete()\n        except:\n            pass\n    else:\n        try:\n            for i in range(len(self.__container__.Rules)):\n                if self.__container__.Rules[i].policy == self.name:\n                    self.__container__.Rules[i].policy = policy\n        except:\n            pass\n    try:\n        self.__container__.ProxyGroups.remove(self)\n    except:\n        pass\n    try:\n        for i in range(len(self.__container__.ProxyGroups) - 1, -1, -1):\n            select(\n                self.__container__.ProxyGroups[i].proxies, False, name=self.name).delete()\n    except:\n        pass\n</code></pre>"},{"location":"ConfigHandler/#rule","title":"Rule","text":""},{"location":"ConfigHandler/#SmartMixin.Rule","title":"SmartMixin.Rule","text":"<p>Rule is a class that represents a rule defined in the Clash YAML configuration. It has properties  like type, argument, policy, and no_resolve. The class can be initialized with  either a YAML string or individual properties.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>class Rule:\n    \"\"\"\n    Rule is a class that represents a rule defined in the Clash YAML configuration. It has properties \n    like type, argument, policy, and no_resolve. The class can be initialized with \n    either a YAML string or individual properties.\n    \"\"\"\n\n    def __init__(self, YAML: str = None, type: str = None, argument: str = None, policy: str = None, no_resolve: bool = False) -&gt; None:\n        \"\"\"\n        Initialize the Rule object with either a YAML string or individual properties.\n\n        Args:\n            YAML (str, optional): A string representing a rule in YAML format. Defaults to None.\n            type (str, optional): The type of the rule. Defaults to None. For example, \"DOMAIN\".\n            argument (str, optional): The argument of the rule. Defaults to None. For example, \"example.com\".\n            policy (str, optional): The policy of the rule. Defaults to None. For example, \"DIRECT\".\n            no_resolve (bool, optional): A flag indicating whether the rule should be resolved. \n            Defaults to False.\n\n        Raises:\n            ValueError: If both YAML and individual properties are None.\n        \"\"\"\n\n        if (type == None or argument == None or policy == None) and YAML == None:\n            raise ValueError\n        elif YAML == None:\n            self.type = type\n            self.argument = argument\n            self.policy = policy\n            self.no_resolve = no_resolve\n        else:\n            soup = yaml.load(YAML.encode(\"utf-8\"), Loader=yaml.Loader)\n            if isinstance(soup, list):\n                soup = soup[0]\n            self.YAML = soup\n\n    @property\n    def no_resolve(self) -&gt; bool:\n        \"\"\"\n        Get the no_resolve property of the rule.\n\n        Returns:\n            bool: True if the rule should not be resolved, False otherwise.\n        \"\"\"\n\n        return self.no_resolve\n\n    @no_resolve.setter\n    def no_resolve(self, no_resolve: bool) -&gt; None:\n        \"\"\"\n        Set the no_resolve property of the rule.\n\n        Args:\n            no_resolve (bool): True if the rule should not be resolved, False otherwise.\n        \"\"\"\n\n        if no_resolve:\n            self._no_resolve = \"no-resolve\"\n        else:\n            self._no_resolve = \"\"\n\n    @property\n    def YAML(self) -&gt; str:\n        \"\"\"\n        Get the YAML representation of the rule.\n\n        Returns:\n            str: The YAML representation of the rule.\n        \"\"\"\n\n        return \",\".join(filter(bool, [self.type, self.argument, self.policy, self._no_resolve]))\n\n    @YAML.setter\n    def YAML(self, YAML: str) -&gt; None:\n        \"\"\"\n        Set the properties of the rule from a YAML string.\n\n        Args:\n            YAML (str): A string representing a rule in YAML format.\n        \"\"\"\n\n        tmp = YAML.split(\",\")\n        if \"no-resolve\" in tmp:\n            self.no_resolve = True\n            tmp.remove(\"no-resolve\")\n        else:\n            self.no_resolve = False\n\n        if len(tmp) == 3:\n            self.type = tmp[0]\n            self.argument = tmp[1]\n            self.policy = tmp[2]\n        else:\n            self.type = None\n            self.argument = tmp[0]\n            self.policy = tmp[1]\n\n    def delete(self) -&gt; None:\n        \"\"\"\n        Delete the rule.\n        \"\"\"\n\n        try:\n            self.__container__.Rules.remove(self)\n        except:\n            pass\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Get a string representation of the rule.\n\n        Returns:\n            str: A string representation of the rule.\n        \"\"\"\n\n        return f\"&lt;PreProcessor.Rule object {self.YAML} at {hex(id(self))}&gt;\"\n\n    def BATCH(YAML: str) -&gt; list:\n        \"\"\"\n        Create a list of Rule objects from a YAML string.\n\n        Args:\n            YAML (str): A string representing multiple rules in YAML format.\n\n        Raises:\n            ValueError: If the YAML string does not represent a list of rules.\n\n        Returns:\n            list: A list of Rule objects.\n        \"\"\"\n\n        soup = yaml.load(YAML.encode(\"utf-8\"), Loader=yaml.Loader)\n        if isinstance(soup, list):\n            return [Rule(i) for i in soup]\n        else:\n            raise ValueError(\"YAML List Expected\")\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.Rule.YAML","title":"YAML  <code>property</code> <code>writable</code>","text":"<pre><code>YAML: str\n</code></pre> <p>Get the YAML representation of the rule.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The YAML representation of the rule.</p>"},{"location":"ConfigHandler/#SmartMixin.Rule.no_resolve","title":"no_resolve  <code>property</code> <code>writable</code>","text":"<pre><code>no_resolve: bool\n</code></pre> <p>Get the no_resolve property of the rule.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the rule should not be resolved, False otherwise.</p>"},{"location":"ConfigHandler/#SmartMixin.Rule.BATCH","title":"BATCH","text":"<pre><code>BATCH(YAML: str) -&gt; list\n</code></pre> <p>Create a list of Rule objects from a YAML string.</p> <p>Parameters:</p> Name Type Description Default <code>YAML</code> <code>str</code> <p>A string representing multiple rules in YAML format.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the YAML string does not represent a list of rules.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of Rule objects.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>def BATCH(YAML: str) -&gt; list:\n    \"\"\"\n    Create a list of Rule objects from a YAML string.\n\n    Args:\n        YAML (str): A string representing multiple rules in YAML format.\n\n    Raises:\n        ValueError: If the YAML string does not represent a list of rules.\n\n    Returns:\n        list: A list of Rule objects.\n    \"\"\"\n\n    soup = yaml.load(YAML.encode(\"utf-8\"), Loader=yaml.Loader)\n    if isinstance(soup, list):\n        return [Rule(i) for i in soup]\n    else:\n        raise ValueError(\"YAML List Expected\")\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.Rule.__init__","title":"__init__","text":"<pre><code>__init__(YAML: str = None, type: str = None, argument: str = None, policy: str = None, no_resolve: bool = False) -&gt; None\n</code></pre> <p>Initialize the Rule object with either a YAML string or individual properties.</p> <p>Parameters:</p> Name Type Description Default <code>YAML</code> <code>str</code> <p>A string representing a rule in YAML format. Defaults to None.</p> <code>None</code> <code>type</code> <code>str</code> <p>The type of the rule. Defaults to None. For example, \"DOMAIN\".</p> <code>None</code> <code>argument</code> <code>str</code> <p>The argument of the rule. Defaults to None. For example, \"example.com\".</p> <code>None</code> <code>policy</code> <code>str</code> <p>The policy of the rule. Defaults to None. For example, \"DIRECT\".</p> <code>None</code> <code>no_resolve</code> <code>bool</code> <p>A flag indicating whether the rule should be resolved. </p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both YAML and individual properties are None.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>def __init__(self, YAML: str = None, type: str = None, argument: str = None, policy: str = None, no_resolve: bool = False) -&gt; None:\n    \"\"\"\n    Initialize the Rule object with either a YAML string or individual properties.\n\n    Args:\n        YAML (str, optional): A string representing a rule in YAML format. Defaults to None.\n        type (str, optional): The type of the rule. Defaults to None. For example, \"DOMAIN\".\n        argument (str, optional): The argument of the rule. Defaults to None. For example, \"example.com\".\n        policy (str, optional): The policy of the rule. Defaults to None. For example, \"DIRECT\".\n        no_resolve (bool, optional): A flag indicating whether the rule should be resolved. \n        Defaults to False.\n\n    Raises:\n        ValueError: If both YAML and individual properties are None.\n    \"\"\"\n\n    if (type == None or argument == None or policy == None) and YAML == None:\n        raise ValueError\n    elif YAML == None:\n        self.type = type\n        self.argument = argument\n        self.policy = policy\n        self.no_resolve = no_resolve\n    else:\n        soup = yaml.load(YAML.encode(\"utf-8\"), Loader=yaml.Loader)\n        if isinstance(soup, list):\n            soup = soup[0]\n        self.YAML = soup\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.Rule.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Get a string representation of the rule.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the rule.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Get a string representation of the rule.\n\n    Returns:\n        str: A string representation of the rule.\n    \"\"\"\n\n    return f\"&lt;PreProcessor.Rule object {self.YAML} at {hex(id(self))}&gt;\"\n</code></pre>"},{"location":"ConfigHandler/#SmartMixin.Rule.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete the rule.</p> Source code in <code>SmartMixin/handler.py</code> <pre><code>def delete(self) -&gt; None:\n    \"\"\"\n    Delete the rule.\n    \"\"\"\n\n    try:\n        self.__container__.Rules.remove(self)\n    except:\n        pass\n</code></pre>"},{"location":"Helpers/","title":"Helpers","text":""},{"location":"Helpers/#selector","title":"Selector","text":""},{"location":"Helpers/#hint","title":"Hint","text":"<p>Member function call applied on the selector will apply to item(s) returned.</p> <pre><code>select_all(conf.Proxies, False, name=\"a\").delete(globally=True)\n\n# is equivalent to\n\nfor i in select_all(conf.Proxies, False, name=\"a\"):\n    i.delete(globally=True)\n</code></pre>"},{"location":"Helpers/#SmartMixin.select","title":"SmartMixin.select","text":"<pre><code>select(__iterable: Iterable, reverse: bool = False, **kwargs) -&gt; EmptySelector | object\n</code></pre> <p>Selects the first element from an iterable that matches specified conditions.  The conditions are provided as keyword arguments where the key is the attribute  name and the value is the expected attribute value. If the key starts with \"re_\",  a regular expression search is performed on the attribute value.</p> <p>If no element matches the conditions, an EmptySelector is returned.</p> <p>Parameters:</p> Name Type Description Default <code>__iterable</code> <code>Iterable</code> <p>The iterable from which to select elements.</p> required <code>reverse</code> <code>bool</code> <p>If True, the first element that does not meet </p> <code>False</code> <p>Returns:</p> Type Description <code>EmptySelector | object</code> <p>Union[EmptySelector, object]: The first element that matches the conditions </p> <code>EmptySelector | object</code> <p>or an EmptySelector if no element matches the conditions.</p> Source code in <code>SmartMixin/helpers.py</code> <pre><code>def select(__iterable: Iterable, reverse: bool = False, **kwargs) -&gt; EmptySelector | object:\n    \"\"\"\n    Selects the first element from an iterable that matches specified conditions. \n    The conditions are provided as keyword arguments where the key is the attribute \n    name and the value is the expected attribute value. If the key starts with \"re_\", \n    a regular expression search is performed on the attribute value.\n\n    If no element matches the conditions, an EmptySelector is returned.\n\n    Args:\n        __iterable (Iterable): The iterable from which to select elements.\n        reverse (bool, optional): If True, the first element that does not meet \n        the conditions is selected. If False, the first element that meets the \n        conditions is selected. Defaults to False.\n\n    Returns:\n        Union[EmptySelector, object]: The first element that matches the conditions \n        or an EmptySelector if no element matches the conditions.\n    \"\"\"\n\n    for i in __iterable:\n        tmp = True\n        for j in kwargs.keys():\n            if j.startswith(\"re_\"):\n                if not re.search(kwargs[j], getattr(i, j[3:])):\n                    tmp = False\n                    break\n            else:\n                if not kwargs[j] == getattr(i, j):\n                    tmp = False\n                    break\n        if tmp and not reverse:\n            return i\n        elif not tmp and reverse:\n            return i\n    return EmptySelector()\n</code></pre>"},{"location":"Helpers/#SmartMixin.select_all","title":"SmartMixin.select_all","text":"<pre><code>select_all(__iterable: Iterable, reverse: bool = False, **kwargs) -&gt; MultiSelector\n</code></pre> <p>Selects elements from an iterable based on specified conditions. The conditions  are provided as keyword arguments where the key is the attribute name and the  value is the expected attribute value. If the key starts with \"re_\", a regular  expression search is performed on the attribute value.</p> <p>Parameters:</p> Name Type Description Default <code>__iterable</code> <code>Iterable</code> <p>The iterable from which to select elements.</p> required <code>reverse</code> <code>bool</code> <p>If True, elements that do not meet the conditions </p> <code>False</code> <p>Returns:</p> Name Type Description <code>MultiSelector</code> <code>MultiSelector</code> <p>A MultiSelector object containing the selected elements.</p> Source code in <code>SmartMixin/helpers.py</code> <pre><code>def select_all(__iterable: Iterable, reverse: bool = False, **kwargs) -&gt; MultiSelector:\n    \"\"\"\n    Selects elements from an iterable based on specified conditions. The conditions \n    are provided as keyword arguments where the key is the attribute name and the \n    value is the expected attribute value. If the key starts with \"re_\", a regular \n    expression search is performed on the attribute value.\n\n    Args:\n        __iterable (Iterable): The iterable from which to select elements.\n        reverse (bool, optional): If True, elements that do not meet the conditions \n        are selected. If False, elements that meet the conditions are selected. \n        Defaults to False.\n\n    Returns:\n        MultiSelector: A MultiSelector object containing the selected elements.\n    \"\"\"\n\n    result = []\n    for i in __iterable:\n        tmp = True\n        for j in kwargs.keys():\n            if j.startswith(\"re_\"):\n                if not re.search(kwargs[j], getattr(i, j[3:])):\n                    tmp = False\n                    break\n            else:\n                if not kwargs[j] == getattr(i, j):\n                    tmp = False\n                    break\n        if tmp and not reverse:\n            result.append(i)\n        elif not tmp and reverse:\n            result.append(i)\n    return MultiSelector(result)\n</code></pre>"},{"location":"Helpers/#container-helper","title":"Container Helper","text":""},{"location":"Helpers/#SmartMixin.extend_back","title":"SmartMixin.extend_back","text":"<pre><code>extend_back(li: list, __iterable: Iterable) -&gt; None\n</code></pre> <p>Extends a list by appending all the items from an iterable at the end.  The iterable must be a list.</p> <p>Parameters:</p> Name Type Description Default <code>li</code> <code>list</code> <p>The list to be extended.</p> required <code>__iterable</code> <code>Iterable</code> <p>The iterable with items to append to the list.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the iterable is not a list.</p> Source code in <code>SmartMixin/helpers.py</code> <pre><code>def extend_back(li: list, __iterable: Iterable) -&gt; None:\n    \"\"\"\n    Extends a list by appending all the items from an iterable at the end. \n    The iterable must be a list.\n\n    Args:\n        li (list): The list to be extended.\n        __iterable (Iterable): The iterable with items to append to the list.\n\n    Raises:\n        ValueError: If the iterable is not a list.\n    \"\"\"\n\n    if not isinstance(__iterable, list):\n        raise ValueError(\"YAML List Expected\")\n    li.extend(__iterable)\n</code></pre>"},{"location":"Helpers/#SmartMixin.extend_front","title":"SmartMixin.extend_front","text":"<pre><code>extend_front(li: list, __iterable: Iterable) -&gt; None\n</code></pre> <p>Extends a list by inserting all the items from an iterable at the beginning.  The iterable must be a list.</p> <p>Parameters:</p> Name Type Description Default <code>li</code> <code>list</code> <p>The list to be extended.</p> required <code>__iterable</code> <code>Iterable</code> <p>The iterable with items to insert at the beginning of the list.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the iterable is not a list.</p> Source code in <code>SmartMixin/helpers.py</code> <pre><code>def extend_front(li: list, __iterable: Iterable) -&gt; None:\n    \"\"\"\n    Extends a list by inserting all the items from an iterable at the beginning. \n    The iterable must be a list.\n\n    Args:\n        li (list): The list to be extended.\n        __iterable (Iterable): The iterable with items to insert at the beginning of the list.\n\n    Raises:\n        ValueError: If the iterable is not a list.\n    \"\"\"\n\n    if not isinstance(__iterable, list):\n        raise ValueError(\"YAML List Expected\")\n    li[0:0] = __iterable\n</code></pre>"},{"location":"Helpers/#SmartMixin.append_back","title":"SmartMixin.append_back","text":"<pre><code>append_back(li: list, __object) -&gt; None\n</code></pre> <p>Appends an object to the end of a list.</p> <p>Parameters:</p> Name Type Description Default <code>li</code> <code>list</code> <p>The list where the object will be appended.</p> required <code>__object</code> <p>The object to be appended to the end of the list.</p> required Source code in <code>SmartMixin/helpers.py</code> <pre><code>def append_back(li: list, __object) -&gt; None:\n    \"\"\"\n    Appends an object to the end of a list.\n\n    Args:\n        li (list): The list where the object will be appended.\n        __object: The object to be appended to the end of the list.\n    \"\"\"\n\n    li.append(__object)\n</code></pre>"},{"location":"Helpers/#SmartMixin.insert_front","title":"SmartMixin.insert_front","text":"<pre><code>insert_front(li: list, __object) -&gt; None\n</code></pre> <p>Inserts an object at the beginning of a list.</p> <p>Parameters:</p> Name Type Description Default <code>li</code> <code>list</code> <p>The list where the object will be inserted.</p> required <code>__object</code> <p>The object to be inserted at the beginning of the list.</p> required Source code in <code>SmartMixin/helpers.py</code> <pre><code>def insert_front(li: list, __object) -&gt; None:\n    \"\"\"\n    Inserts an object at the beginning of a list.\n\n    Args:\n        li (list): The list where the object will be inserted.\n        __object: The object to be inserted at the beginning of the list.\n    \"\"\"\n\n    li.insert(0, __object)\n</code></pre>"},{"location":"Serialization/","title":"Serialization","text":""},{"location":"Serialization/#pickle","title":"Pickle","text":""},{"location":"Serialization/#SmartMixin.loadsConfig","title":"SmartMixin.loadsConfig","text":"<pre><code>loadsConfig(bytes: bytes) -&gt; Config\n</code></pre> <p>Deserialize a Config object from a bytes object using the pickle module.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <code>bytes</code> <p>A bytes object containing a serialized Config object.</p> required <p>Returns:</p> Name Type Description <code>Config</code> <code>Config</code> <p>The deserialized Config object.</p> Source code in <code>SmartMixin/serialization.py</code> <pre><code>def loadsConfig(bytes: bytes) -&gt; Config:\n    \"\"\"\n    Deserialize a Config object from a bytes object using the pickle module.\n\n    Args:\n        bytes (bytes): A bytes object containing a serialized Config object.\n\n    Returns:\n        Config: The deserialized Config object.\n    \"\"\"\n\n    obj = pickle.loads(bytes)\n    r = Config(DICT=obj[0])\n    r._meta = obj[1]\n    return r\n</code></pre>"},{"location":"Serialization/#SmartMixin.dumpsConfig","title":"SmartMixin.dumpsConfig","text":"<pre><code>dumpsConfig(config: Config) -&gt; bytes\n</code></pre> <p>Serialize a Config object into a bytes object using the pickle module.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The Config object to be serialized.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The serialized Config object.</p> Source code in <code>SmartMixin/serialization.py</code> <pre><code>def dumpsConfig(config: Config) -&gt; bytes:\n    \"\"\"\n    Serialize a Config object into a bytes object using the pickle module.\n\n    Args:\n        config (Config): The Config object to be serialized.\n\n    Returns:\n        bytes: The serialized Config object.\n    \"\"\"\n\n    return pickle.dumps((config.DICT, config._meta))\n</code></pre>"}]}